import Vapor
// DisposersApiDelegate.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: /APIs.Disposers


public enum getActUsingGETResponse: ResponseEncodable {
  case http200(ActDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getActsUsingGETResponse: ResponseEncodable {
  case http200(DocumentResultDTOActDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getAddendsUsingGETResponse: ResponseEncodable {
  case http200(DocumentResultDTOAddendumDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getAddendumUsingGETResponse: ResponseEncodable {
  case http200(AddendumDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getAgreementsUsingGETResponse: ResponseEncodable {
  case http200(DocumentResultDTOContractDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getContractUsingGETResponse: ResponseEncodable {
  case http200(ContractWithSubdocumentsDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getCsvActsUsingGETResponse: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getCsvAddendumsUsingGETResponse: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getCsvAgreementsUsingGETResponse: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getCsvPenyUsingGETResponse: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getDataSnapshotUsingGETResponse: ResponseEncodable {
  case http200(ContractDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getDataUsingGETResponse: ResponseEncodable {
  case http200(OrganizationDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getDisposersCsvUsingGETResponse: ResponseEncodable {
  case http200(InputStreamResource)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getFilesListUsingGETResponse: ResponseEncodable {
  case http200([FileDTO])
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getPenaltyUsingGETResponse: ResponseEncodable {
  case http200(PenyDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getPenyUsingGETResponse: ResponseEncodable {
  case http200(DocumentResultDTOPenyDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getReporstHistoryListUsingGETResponse: ResponseEncodable {
  case http200(String)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getReporstHistoryListUsingGET1Response: ResponseEncodable {
  case http200(String)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getReportInfoUsingPOSTResponse: ResponseEncodable {
  case http200(String)
  case http201
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http201:
      let response = Response()
      response.status = HTTPStatus(statusCode: 201)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getStatUsingGETResponse: ResponseEncodable {
  case http200(DisposerStatDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum pingUsingGET2Response: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}

public protocol DisposersApiDelegate {
  associatedtype AuthType
  /**
  GET /v2/disposers/acts/{actId} */
  func getActUsingGET(with req: Request, actId: Int64) throws -> EventLoopFuture<getActUsingGETResponse>
  /**
  GET /v2/disposers/acts */
  func getActsUsingGET(with req: Request, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?) throws -> EventLoopFuture<getActsUsingGETResponse>
  /**
  GET /v2/disposers/addendums */
  func getAddendsUsingGET(with req: Request, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?) throws -> EventLoopFuture<getAddendsUsingGETResponse>
  /**
  GET /v2/disposers/addendums/{addendumId} */
  func getAddendumUsingGET(with req: Request, addendumId: Int64) throws -> EventLoopFuture<getAddendumUsingGETResponse>
  /**
  GET /v2/disposers/contracts */
  func getAgreementsUsingGET(with req: Request, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?, enabledInDateFrom: Date?, enabledInDateTo: Date?) throws -> EventLoopFuture<getAgreementsUsingGETResponse>
  /**
  GET /v2/disposers/contracts/{contractId} */
  func getContractUsingGET(with req: Request, contractId: Int64) throws -> EventLoopFuture<getContractUsingGETResponse>
  /**
  GET /v2/disposers/acts/{edrpou}/csv */
  func getCsvActsUsingGET(with req: Request, edrpou: String, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?) throws -> EventLoopFuture<getCsvActsUsingGETResponse>
  /**
  GET /v2/disposers/addendums/{edrpou}/csv */
  func getCsvAddendumsUsingGET(with req: Request, edrpou: String, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?) throws -> EventLoopFuture<getCsvAddendumsUsingGETResponse>
  /**
  GET /v2/disposers/contracts/{edrpou}/csv */
  func getCsvAgreementsUsingGET(with req: Request, edrpou: String, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?, enabledInDateFrom: Date?, enabledInDateTo: Date?) throws -> EventLoopFuture<getCsvAgreementsUsingGETResponse>
  /**
  GET /v2/disposers/peny/{edrpou}/csv */
  func getCsvPenyUsingGET(with req: Request, edrpou: String, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?, enabledInDateFrom: Date?, enabledInDateTo: Date?) throws -> EventLoopFuture<getCsvPenyUsingGETResponse>
  /**
  GET /v2/disposers/snapshot/{date}/{type} */
  func getDataSnapshotUsingGET(with req: Request, date: String, type: String) throws -> EventLoopFuture<getDataSnapshotUsingGETResponse>
  /**
  GET /v2/disposers/{edrpou} */
  func getDataUsingGET(with req: Request, edrpou: String) throws -> EventLoopFuture<getDataUsingGETResponse>
  /**
  GET /v2/disposers/csv */
  func getDisposersCsvUsingGET(with req: Request, regionIds: [Int]?, edrpou: String?, organizationName: String?, kopfg: Int?, orgEdrState: Int?, hasCabinet: Bool?) throws -> EventLoopFuture<getDisposersCsvUsingGETResponse>
  /**
  GET /v2/disposers/files */
  func getFilesListUsingGET(with req: Request) throws -> EventLoopFuture<getFilesListUsingGETResponse>
  /**
  GET /v2/disposers/peny/{penyId} */
  func getPenaltyUsingGET(with req: Request, penyId: Int64) throws -> EventLoopFuture<getPenaltyUsingGETResponse>
  /**
  GET /v2/disposers/peny */
  func getPenyUsingGET(with req: Request, documentId: [String]?, disposerId: [String]?, contractorId: [String]?, currency: [String]?, names: [String]?, documentDateFrom: Date?, documentDateTo: Date?, signDateFrom: Date?, signDateTo: Date?, amountFrom: Double?, amountTo: Double?, documentNumber: String?, version: Bool?) throws -> EventLoopFuture<getPenyUsingGETResponse>
  /**
  GET /v2/disposers/{edrpou}/{docId}/history/{historyId} */
  func getReporstHistoryListUsingGET(with req: Request, edrpou: String, docId: Int64, historyId: Int) throws -> EventLoopFuture<getReporstHistoryListUsingGETResponse>
  /**
  GET /v2/disposers/{edrpou}/{docId}/history */
  func getReporstHistoryListUsingGET1(with req: Request, edrpou: String, docId: Int64) throws -> EventLoopFuture<getReporstHistoryListUsingGET1Response>
  /**
  POST /v2/disposers/documents/signinfo */
  func getReportInfoUsingPOST(with req: Request, body: CheckSignRequestDTO) throws -> EventLoopFuture<getReportInfoUsingPOSTResponse>
  /**
  GET /v2/disposers/stat/{edrpou} */
  func getStatUsingGET(with req: Request, edrpou: String) throws -> EventLoopFuture<getStatUsingGETResponse>
  /**
  GET /v2/disposers/ping */
  func pingUsingGET2(with req: Request) throws -> EventLoopFuture<pingUsingGET2Response>
}

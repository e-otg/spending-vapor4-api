import Vapor
// TransactionsApiDelegate.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: /APIs.Transactions


public enum getPageUsingGET1Response: ResponseEncodable {
  case http200(TransactionsPageDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getTop100UsingGETResponse: ResponseEncodable {
  case http200([TransactionDTO])
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getTop5UsingGETResponse: ResponseEncodable {
  case http200([TopTransaction])
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getTransactionDetailsUsingGETResponse: ResponseEncodable {
  case http200(TransactionDTO)
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum getTransactionsByStreamUsingGETResponse: ResponseEncodable {
  case http200([TransactionDTO])
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum lastLoadUsingGET1Response: ResponseEncodable {
  case http200([LastLoadDTO])
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200(let content):
      return content.encodeResponse(for: request).map { (response: Response) -> (Response) in
        response.status = HTTPStatus(statusCode: 200)
        return response
      }
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum pingUsingGET8Response: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}


public enum pingUsingGET9Response: ResponseEncodable {
  case http200
  case http401
  case http403
  case http404

  public func encodeResponse(for request: Request) -> EventLoopFuture<Response> {
    switch self {
    case .http200:
      let response = Response()
      response.status = HTTPStatus(statusCode: 200)
      return request.eventLoop.makeSucceededFuture(response)
    case .http401:
      let response = Response()
      response.status = HTTPStatus(statusCode: 401)
      return request.eventLoop.makeSucceededFuture(response)
    case .http403:
      let response = Response()
      response.status = HTTPStatus(statusCode: 403)
      return request.eventLoop.makeSucceededFuture(response)
    case .http404:
      let response = Response()
      response.status = HTTPStatus(statusCode: 404)
      return request.eventLoop.makeSucceededFuture(response)
    }
  }
}

public protocol TransactionsApiDelegate {
  associatedtype AuthType
  /**
  GET /v2/api/transactions/page/ */
  func getPageUsingGET1(with req: Request, payersEdrpous: [String]?, reciptEdrpous: [String]?, regions: [Int]?, source: String?, startdate: Date?, enddate: Date?, payerAccount: String?, reciptAccount: String?, sumFrom: Decimal?, sumTo: Decimal?, purpose: String?, payerName: String?, reciptName: String?, payerNameEdrpou: String?, reciptNameEdrpou: String?, page: Int?, pageSize: Int?) throws -> EventLoopFuture<getPageUsingGET1Response>
  /**
  GET /v2/api/transactions/top100 */
  func getTop100UsingGET(with req: Request, region: [Int]?) throws -> EventLoopFuture<getTop100UsingGETResponse>
  /**
  GET /v2/api/transactions/top5 */
  func getTop5UsingGET(with req: Request) throws -> EventLoopFuture<getTop5UsingGETResponse>
  /**
  GET /v2/api/transactions/{disposer}/{transactionId} */
  func getTransactionDetailsUsingGET(with req: Request, disposer: String, transactionId: Int64) throws -> EventLoopFuture<getTransactionDetailsUsingGETResponse>
  /**
  GET /v2/api/transactions/ */
  func getTransactionsByStreamUsingGET(with req: Request, payersEdrpous: [String]?, reciptEdrpous: [String]?, regions: [Int]?, source: String?, startdate: Date?, enddate: Date?, payerAccount: String?, reciptAccount: String?, sumFrom: Decimal?, sumTo: Decimal?, purpose: String?, payerName: String?, reciptName: String?, payerNameEdrpou: String?, reciptNameEdrpou: String?, key: String?) throws -> EventLoopFuture<getTransactionsByStreamUsingGETResponse>
  /**
  GET /v2/api/transactions/lastload */
  func lastLoadUsingGET1(with req: Request) throws -> EventLoopFuture<lastLoadUsingGET1Response>
  /**
  GET /v2/api/transactions/ping */
  func pingUsingGET8(with req: Request) throws -> EventLoopFuture<pingUsingGET8Response>
  /**
  GET /v2/api/transactions/page/ping */
  func pingUsingGET9(with req: Request) throws -> EventLoopFuture<pingUsingGET9Response>
}

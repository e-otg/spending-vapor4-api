import Vapor
import RoutingKit

// routes.swift
//
// Generated by vapor-server-codegen
// https://github.com/thecheatah/SwiftVapor-swagger-codegen
// Template Input: 

extension String {
  var asPathComponents: [PathComponent] {
    return self.split(separator: "/").map {
      if $0.starts(with: "{") && $0.hasSuffix("}") {
        let start = $0.index($0.startIndex, offsetBy: 1)
        let end = $0.index($0.endIndex, offsetBy: -1)
        return PathComponent.parameter(String($0[start..<end]))
      } else {
        return PathComponent.constant(.init($0))
      }
    }
  }
}

public protocol AuthenticationMiddleware: Middleware {
  associatedtype AuthType: Authenticatable
  func authType() -> AuthType.Type
}

//Used when auth is not used
public class DummyAuthType: Authenticatable {}

public func routes<budget: BudgetApiDelegate, dictionaries: DictionariesApiDelegate, disposers: DisposersApiDelegate, googleAnalyticStatistic: GoogleAnalyticStatisticApiDelegate, map: MapApiDelegate, pageableDisposers: PageableDisposersApiDelegate, regions: RegionsApiDelegate, reports: ReportsApiDelegate, statistic: StatisticApiDelegate, transactions: TransactionsApiDelegate>
  (_ app: RoutesBuilder, budget: budget, dictionaries: dictionaries, disposers: disposers, googleAnalyticStatistic: googleAnalyticStatistic, map: map, pageableDisposers: pageableDisposers, regions: regions, reports: reports, statistic: statistic, transactions: transactions)
  throws
  where budget.AuthType == DummyAuthType.Type, dictionaries.AuthType == DummyAuthType.Type, disposers.AuthType == DummyAuthType.Type, googleAnalyticStatistic.AuthType == DummyAuthType.Type, map.AuthType == DummyAuthType.Type, pageableDisposers.AuthType == DummyAuthType.Type, regions.AuthType == DummyAuthType.Type, reports.AuthType == DummyAuthType.Type, statistic.AuthType == DummyAuthType.Type, transactions.AuthType == DummyAuthType.Type
  {
  //for budget
  app.on(.GET, "/v2/budget/dict/inc".asPathComponents) { (request: Request) -> EventLoopFuture<incUsingGETResponse> in
    if !request.headers.contains(name: "Authorization") {
      throw Abort(.badRequest, reason: "Missing header: Authorization")
    }
    let authorization = request.headers["Authorization"][0]
    return try budget.incUsingGET(with: request, authorization: authorization)
  }
  app.on(.GET, "/v2/budget/dict/kek".asPathComponents) { (request: Request) -> EventLoopFuture<kekUsingGETResponse> in
    if !request.headers.contains(name: "Authorization") {
      throw Abort(.badRequest, reason: "Missing header: Authorization")
    }
    let authorization = request.headers["Authorization"][0]
    return try budget.kekUsingGET(with: request, authorization: authorization)
  }
  //for dictionaries
  app.on(.GET, "/v2/dictionaries/koatuu".asPathComponents) { (request: Request) -> EventLoopFuture<getAddressByKoatuuUsingGETResponse> in
    let koatuuOptional = try? request.query.get(String.self, at: "koatuu")
    guard let koatuu = koatuuOptional else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing query parameter koatuu")
    }
    return try dictionaries.getAddressByKoatuuUsingGET(with: request, koatuu: koatuu)
  }
  app.on(.GET, "/v2/dictionaries/contractors".asPathComponents) { (request: Request) -> EventLoopFuture<getContractorTypesUsingGETResponse> in
    return try dictionaries.getContractorTypesUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/countries".asPathComponents) { (request: Request) -> EventLoopFuture<getCountriesUsingGETResponse> in
    return try dictionaries.getCountriesUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/currency".asPathComponents) { (request: Request) -> EventLoopFuture<getCurrencyListUsingGETResponse> in
    return try dictionaries.getCurrencyListUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/dkpp".asPathComponents) { (request: Request) -> EventLoopFuture<getDkppUsingGETResponse> in
    return try dictionaries.getDkppUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/DKSUdepartments".asPathComponents) { (request: Request) -> EventLoopFuture<getDksuDepartmentsUsingGETResponse> in
    return try dictionaries.getDksuDepartmentsUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/kved/{exactKved}".asPathComponents) { (request: Request) -> EventLoopFuture<getExactKvedUsingGETResponse> in
    guard let exactKved = request.parameters.get("exactKved", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter exactKved")
    }
    return try dictionaries.getExactKvedUsingGET(with: request, exactKved: exactKved)
  }
  app.on(.GET, "/v2/dictionaries/kopfg".asPathComponents) { (request: Request) -> EventLoopFuture<getKopfgUsingGETResponse> in
    return try dictionaries.getKopfgUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/kved".asPathComponents) { (request: Request) -> EventLoopFuture<getKvedUsingGETResponse> in
    return try dictionaries.getKvedUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/organizationtypes".asPathComponents) { (request: Request) -> EventLoopFuture<getOrgTypesUsingGETResponse> in
    return try dictionaries.getOrgTypesUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/procurement".asPathComponents) { (request: Request) -> EventLoopFuture<getProcurementDictionaryUsingGETResponse> in
    let lang = try? request.query.get(String.self, at: "lang")
    return try dictionaries.getProcurementDictionaryUsingGET(with: request, lang: lang)
  }
  app.on(.GET, "/v2/dictionaries/regions".asPathComponents) { (request: Request) -> EventLoopFuture<getRegionsUsingGETResponse> in
    return try dictionaries.getRegionsUsingGET(with: request)
  }
  app.on(.GET, "/v2/dictionaries/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET1Response> in
    return try dictionaries.pingUsingGET1(with: request)
  }
  //for disposers
  app.on(.GET, "/v2/disposers/acts/{actId}".asPathComponents) { (request: Request) -> EventLoopFuture<getActUsingGETResponse> in
    guard let actId = request.parameters.get("actId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter actId")
    }
    return try disposers.getActUsingGET(with: request, actId: actId)
  }
  app.on(.GET, "/v2/disposers/acts".asPathComponents) { (request: Request) -> EventLoopFuture<getActsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    return try disposers.getActsUsingGET(with: request, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version)
  }
  app.on(.GET, "/v2/disposers/addendums".asPathComponents) { (request: Request) -> EventLoopFuture<getAddendsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    return try disposers.getAddendsUsingGET(with: request, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version)
  }
  app.on(.GET, "/v2/disposers/addendums/{addendumId}".asPathComponents) { (request: Request) -> EventLoopFuture<getAddendumUsingGETResponse> in
    guard let addendumId = request.parameters.get("addendumId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter addendumId")
    }
    return try disposers.getAddendumUsingGET(with: request, addendumId: addendumId)
  }
  app.on(.GET, "/v2/disposers/contracts".asPathComponents) { (request: Request) -> EventLoopFuture<getAgreementsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    let enabledInDateFrom = try? request.query.get(Date.self, at: "enabledInDateFrom")
    let enabledInDateTo = try? request.query.get(Date.self, at: "enabledInDateTo")
    return try disposers.getAgreementsUsingGET(with: request, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version, enabledInDateFrom: enabledInDateFrom, enabledInDateTo: enabledInDateTo)
  }
  app.on(.GET, "/v2/disposers/contracts/{contractId}".asPathComponents) { (request: Request) -> EventLoopFuture<getContractUsingGETResponse> in
    guard let contractId = request.parameters.get("contractId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter contractId")
    }
    return try disposers.getContractUsingGET(with: request, contractId: contractId)
  }
  app.on(.GET, "/v2/disposers/acts/{edrpou}/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvActsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getCsvActsUsingGET(with: request, edrpou: edrpou, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version)
  }
  app.on(.GET, "/v2/disposers/addendums/{edrpou}/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvAddendumsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getCsvAddendumsUsingGET(with: request, edrpou: edrpou, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version)
  }
  app.on(.GET, "/v2/disposers/contracts/{edrpou}/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvAgreementsUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    let enabledInDateFrom = try? request.query.get(Date.self, at: "enabledInDateFrom")
    let enabledInDateTo = try? request.query.get(Date.self, at: "enabledInDateTo")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getCsvAgreementsUsingGET(with: request, edrpou: edrpou, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version, enabledInDateFrom: enabledInDateFrom, enabledInDateTo: enabledInDateTo)
  }
  app.on(.GET, "/v2/disposers/peny/{edrpou}/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvPenyUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    let enabledInDateFrom = try? request.query.get(Date.self, at: "enabledInDateFrom")
    let enabledInDateTo = try? request.query.get(Date.self, at: "enabledInDateTo")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getCsvPenyUsingGET(with: request, edrpou: edrpou, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version, enabledInDateFrom: enabledInDateFrom, enabledInDateTo: enabledInDateTo)
  }
  app.on(.GET, "/v2/disposers/snapshot/{date}/{type}".asPathComponents) { (request: Request) -> EventLoopFuture<getDataSnapshotUsingGETResponse> in
    guard let date = request.parameters.get("date", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter date")
    }
    guard let type = request.parameters.get("type", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter type")
    }
    return try disposers.getDataSnapshotUsingGET(with: request, date: date, type: type)
  }
  app.on(.GET, "/v2/disposers/{edrpou}".asPathComponents) { (request: Request) -> EventLoopFuture<getDataUsingGETResponse> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getDataUsingGET(with: request, edrpou: edrpou)
  }
  app.on(.GET, "/v2/disposers/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getDisposersCsvUsingGETResponse> in
    let regionIds = try? request.query.get([Int].self, at: "regionIds")
    let edrpou = try? request.query.get(String.self, at: "edrpou")
    let organizationName = try? request.query.get(String.self, at: "organizationName")
    let kopfg = try? request.query.get(Int.self, at: "kopfg")
    let orgEdrState = try? request.query.get(Int.self, at: "orgEdrState")
    let hasCabinet = try? request.query.get(Bool.self, at: "hasCabinet")
    return try disposers.getDisposersCsvUsingGET(with: request, regionIds: regionIds, edrpou: edrpou, organizationName: organizationName, kopfg: kopfg, orgEdrState: orgEdrState, hasCabinet: hasCabinet)
  }
  app.on(.GET, "/v2/disposers/files".asPathComponents) { (request: Request) -> EventLoopFuture<getFilesListUsingGETResponse> in
    return try disposers.getFilesListUsingGET(with: request)
  }
  app.on(.GET, "/v2/disposers/peny/{penyId}".asPathComponents) { (request: Request) -> EventLoopFuture<getPenaltyUsingGETResponse> in
    guard let penyId = request.parameters.get("penyId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter penyId")
    }
    return try disposers.getPenaltyUsingGET(with: request, penyId: penyId)
  }
  app.on(.GET, "/v2/disposers/peny".asPathComponents) { (request: Request) -> EventLoopFuture<getPenyUsingGETResponse> in
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    return try disposers.getPenyUsingGET(with: request, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version)
  }
  app.on(.GET, "/v2/disposers/{edrpou}/{docId}/history/{historyId}".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGETResponse> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    guard let docId = request.parameters.get("docId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter docId")
    }
    guard let historyId = request.parameters.get("historyId", as: Int.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter historyId")
    }
    return try disposers.getReporstHistoryListUsingGET(with: request, edrpou: edrpou, docId: docId, historyId: historyId)
  }
  app.on(.GET, "/v2/disposers/{edrpou}/{docId}/history".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGET1Response> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    guard let docId = request.parameters.get("docId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter docId")
    }
    return try disposers.getReporstHistoryListUsingGET1(with: request, edrpou: edrpou, docId: docId)
  }
  app.on(.POST, "/v2/disposers/documents/signinfo".asPathComponents) { (request: Request) -> EventLoopFuture<getReportInfoUsingPOSTResponse> in
    let body = try request.content.decode(CheckSignRequestDTO.self)
    return try disposers.getReportInfoUsingPOST(with: request, body: body)
  }
  app.on(.GET, "/v2/disposers/stat/{edrpou}".asPathComponents) { (request: Request) -> EventLoopFuture<getStatUsingGETResponse> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try disposers.getStatUsingGET(with: request, edrpou: edrpou)
  }
  app.on(.GET, "/v2/disposers/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET2Response> in
    return try disposers.pingUsingGET2(with: request)
  }
  //for googleAnalyticStatistic
  app.on(.GET, "/v2/googleStat/age".asPathComponents) { (request: Request) -> EventLoopFuture<getAgeStatUsingGETResponse> in
    return try googleAnalyticStatistic.getAgeStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/googleStat/browser".asPathComponents) { (request: Request) -> EventLoopFuture<getBrowserStatUsingGETResponse> in
    return try googleAnalyticStatistic.getBrowserStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/googleStat/device".asPathComponents) { (request: Request) -> EventLoopFuture<getDeviceStatUsingGETResponse> in
    return try googleAnalyticStatistic.getDeviceStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/googleStat/gender".asPathComponents) { (request: Request) -> EventLoopFuture<getGenderStatUsingGETResponse> in
    return try googleAnalyticStatistic.getGenderStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/googleStat/regions".asPathComponents) { (request: Request) -> EventLoopFuture<getRegionStatUsingGETResponse> in
    return try googleAnalyticStatistic.getRegionStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/googleStat/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET4Response> in
    return try googleAnalyticStatistic.pingUsingGET4(with: request)
  }
  //for map
  app.on(.GET, "/v2/map/aggregate".asPathComponents) { (request: Request) -> EventLoopFuture<getAggregateDataUsingGETResponse> in
    let lang = try? request.query.get(String.self, at: "lang")
    return try map.getAggregateDataUsingGET(with: request, lang: lang)
  }
  //for pageableDisposers
  app.on(.POST, "/v2/disposers/page".asPathComponents) { (request: Request) -> EventLoopFuture<getDisposersUsingPOSTResponse> in
    let body = try request.content.decode(PagedRequestDistributorRequest.self)
    return try pageableDisposers.getDisposersUsingPOST(with: request, body: body)
  }
  app.on(.GET, "/v2/disposers/page/{docType}".asPathComponents) { (request: Request) -> EventLoopFuture<getDocUsingGETResponse> in
    if !request.headers.contains(name: "X-FILTER-DATA") {
      throw Abort(.badRequest, reason: "Missing header: X-FILTER-DATA")
    }
    let X_FILTER_DATA = request.headers["X-FILTER-DATA"][0]
    let documentId = try? request.query.get([String].self, at: "documentId")
    let disposerId = try? request.query.get([String].self, at: "disposerId")
    let contractorId = try? request.query.get([String].self, at: "contractorId")
    let currency = try? request.query.get([String].self, at: "currency")
    let names = try? request.query.get([String].self, at: "names")
    let documentDateFrom = try? request.query.get(Date.self, at: "documentDateFrom")
    let documentDateTo = try? request.query.get(Date.self, at: "documentDateTo")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let amountFrom = try? request.query.get(Double.self, at: "amountFrom")
    let amountTo = try? request.query.get(Double.self, at: "amountTo")
    let documentNumber = try? request.query.get(String.self, at: "documentNumber")
    let version = try? request.query.get(Bool.self, at: "version")
    let page = try? request.query.get(Int.self, at: "page")
    let pageSize = try? request.query.get(Int.self, at: "pageSize")
    let enabledInDateFrom = try? request.query.get(Date.self, at: "enabledInDateFrom")
    let enabledInDateTo = try? request.query.get(Date.self, at: "enabledInDateTo")
    guard let docType = request.parameters.get("docType", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter docType")
    }
    return try pageableDisposers.getDocUsingGET(with: request, docType: docType, X_FILTER_DATA: X_FILTER_DATA, documentId: documentId, disposerId: disposerId, contractorId: contractorId, currency: currency, names: names, documentDateFrom: documentDateFrom, documentDateTo: documentDateTo, signDateFrom: signDateFrom, signDateTo: signDateTo, amountFrom: amountFrom, amountTo: amountTo, documentNumber: documentNumber, version: version, page: page, pageSize: pageSize, enabledInDateFrom: enabledInDateFrom, enabledInDateTo: enabledInDateTo)
  }
  app.on(.POST, "/v2/disposers/page/ministries".asPathComponents) { (request: Request) -> EventLoopFuture<getMinistriesUsingPOSTResponse> in
    let body = try request.content.decode(PagedRequestVoid.self)
    return try pageableDisposers.getMinistriesUsingPOST(with: request, body: body)
  }
  app.on(.GET, "/v2/disposers/page/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET3Response> in
    return try pageableDisposers.pingUsingGET3(with: request)
  }
  //for regions
  app.on(.GET, "/v2/regions".asPathComponents) { (request: Request) -> EventLoopFuture<getRegionsUsingGET1Response> in
    return try regions.getRegionsUsingGET1(with: request)
  }
  app.on(.GET, "/v2/regions/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET5Response> in
    return try regions.pingUsingGET5(with: request)
  }
  //for reports
  app.on(.GET, "/v2/api/reports/asynch/codes".asPathComponents) { (request: Request) -> EventLoopFuture<codesUsingGETResponse> in
    return try reports.codesUsingGET(with: request)
  }
  app.on(.GET, "/v2/api/reports/asynch".asPathComponents) { (request: Request) -> EventLoopFuture<findAsynchUsingGETResponse> in
    let edrpou = try? request.query.get(String.self, at: "edrpou")
    let reportTypeId = try? request.query.get(Int64.self, at: "reportTypeId")
    let periodId = try? request.query.get(Int64.self, at: "periodId")
    return try reports.findAsynchUsingGET(with: request, edrpou: edrpou, reportTypeId: reportTypeId, periodId: periodId)
  }
  app.on(.GET, "/v2/api/reports/asynch/deleted/{date}".asPathComponents) { (request: Request) -> EventLoopFuture<findByDeletedDateUsingGETResponse> in
    guard let date = request.parameters.get("date", as: Date.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter date")
    }
    return try reports.findByDeletedDateUsingGET(with: request, date: date)
  }
  app.on(.GET, "/v2/api/reports/asynch/date/{date}".asPathComponents) { (request: Request) -> EventLoopFuture<findBySignDateUsingGETResponse> in
    guard let date = request.parameters.get("date", as: Date.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter date")
    }
    return try reports.findBySignDateUsingGET(with: request, date: date)
  }
  app.on(.GET, "/v2/api/reports/asynch/result/{token}".asPathComponents) { (request: Request) -> EventLoopFuture<getAsynchUsingGETResponse> in
    guard let token = request.parameters.get("token", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter token")
    }
    return try reports.getAsynchUsingGET(with: request, token: token)
  }
  app.on(.GET, "/v2/api/reports/{edrpou}/csv/".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvUsingGETResponse> in
    let reportTypeId = try? request.query.get([Int64].self, at: "reportTypeId")
    let periodIds = try? request.query.get([Int64].self, at: "periodIds")
    let edrpou2 = try? request.query.get(String.self, at: "edrpou2")
    let budget = try? request.query.get(String.self, at: "budget")
    let fund = try? request.query.get(String.self, at: "fund")
    let vidClassCode = try? request.query.get(String.self, at: "vidClassCode")
    let progClassCode = try? request.query.get(String.self, at: "progClassCode")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let createDateFrom = try? request.query.get(Date.self, at: "createDateFrom")
    let createDateTo = try? request.query.get(Date.self, at: "createDateTo")
    let signStatus = try? request.query.get(String.self, at: "signStatus")
    let page = try? request.query.get(Int.self, at: "page")
    let size = try? request.query.get(Int.self, at: "size")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try reports.getCsvUsingGET(with: request, edrpou: edrpou, reportTypeId: reportTypeId, periodIds: periodIds, edrpou2: edrpou2, budget: budget, fund: fund, vidClassCode: vidClassCode, progClassCode: progClassCode, signDateFrom: signDateFrom, signDateTo: signDateTo, createDateFrom: createDateFrom, createDateTo: createDateTo, signStatus: signStatus, page: page, size: size)
  }
  app.on(.GET, "/v2/api/reports/kpk/".asPathComponents) { (request: Request) -> EventLoopFuture<getKpkUsingGETResponse> in
    let periodId = try? request.query.get(Int64.self, at: "periodId")
    let budget = try? request.query.get(String.self, at: "budget")
    return try reports.getKpkUsingGET(with: request, periodId: periodId, budget: budget)
  }
  app.on(.GET, "/v2/api/reports/kvk/".asPathComponents) { (request: Request) -> EventLoopFuture<getKvkUsingGETResponse> in
    let periodId = try? request.query.get(Int64.self, at: "periodId")
    let budget = try? request.query.get(String.self, at: "budget")
    return try reports.getKvkUsingGET(with: request, periodId: periodId, budget: budget)
  }
  app.on(.GET, "/v2/api/reports/{edrpou}/page".asPathComponents) { (request: Request) -> EventLoopFuture<getPageUsingGETResponse> in
    let reportTypeId = try? request.query.get([Int64].self, at: "reportTypeId")
    let periodIds = try? request.query.get([Int64].self, at: "periodIds")
    let edrpou2 = try? request.query.get(String.self, at: "edrpou2")
    let budget = try? request.query.get(String.self, at: "budget")
    let fund = try? request.query.get(String.self, at: "fund")
    let vidClassCode = try? request.query.get(String.self, at: "vidClassCode")
    let progClassCode = try? request.query.get(String.self, at: "progClassCode")
    let signDateFrom = try? request.query.get(Date.self, at: "signDateFrom")
    let signDateTo = try? request.query.get(Date.self, at: "signDateTo")
    let createDateFrom = try? request.query.get(Date.self, at: "createDateFrom")
    let createDateTo = try? request.query.get(Date.self, at: "createDateTo")
    let signStatus = try? request.query.get(String.self, at: "signStatus")
    let page = try? request.query.get(Int.self, at: "page")
    let size = try? request.query.get(Int.self, at: "size")
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try reports.getPageUsingGET(with: request, edrpou: edrpou, reportTypeId: reportTypeId, periodIds: periodIds, edrpou2: edrpou2, budget: budget, fund: fund, vidClassCode: vidClassCode, progClassCode: progClassCode, signDateFrom: signDateFrom, signDateTo: signDateTo, createDateFrom: createDateFrom, createDateTo: createDateTo, signStatus: signStatus, page: page, size: size)
  }
  app.on(.GET, "/v2/api/reports/asynch/periods".asPathComponents) { (request: Request) -> EventLoopFuture<getPeriodsUsingGETResponse> in
    return try reports.getPeriodsUsingGET(with: request)
  }
  app.on(.GET, "/v2/api/reports/periods/".asPathComponents) { (request: Request) -> EventLoopFuture<getPeriodsUsingGET1Response> in
    return try reports.getPeriodsUsingGET1(with: request)
  }
  app.on(.GET, "/v2/disposers/{edrpou}/{docId}/history/{historyId}".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGETResponse> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    guard let docId = request.parameters.get("docId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter docId")
    }
    guard let historyId = request.parameters.get("historyId", as: Int.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter historyId")
    }
    return try reports.getReporstHistoryListUsingGET(with: request, edrpou: edrpou, docId: docId, historyId: historyId)
  }
  app.on(.GET, "/v2/disposers/{edrpou}/{docId}/history".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGET1Response> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    guard let docId = request.parameters.get("docId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter docId")
    }
    return try reports.getReporstHistoryListUsingGET1(with: request, edrpou: edrpou, docId: docId)
  }
  app.on(.GET, "/v2/api/reports/{disposer}/{reportId}/history/{historyId}".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGET2Response> in
    guard let disposer = request.parameters.get("disposer", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter disposer")
    }
    guard let reportId = request.parameters.get("reportId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter reportId")
    }
    guard let historyId = request.parameters.get("historyId", as: Int.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter historyId")
    }
    return try reports.getReporstHistoryListUsingGET2(with: request, disposer: disposer, reportId: reportId, historyId: historyId)
  }
  app.on(.GET, "/v2/api/reports/{disposer}/{reportId}/history".asPathComponents) { (request: Request) -> EventLoopFuture<getReporstHistoryListUsingGET3Response> in
    guard let disposer = request.parameters.get("disposer", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter disposer")
    }
    guard let reportId = request.parameters.get("reportId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter reportId")
    }
    return try reports.getReporstHistoryListUsingGET3(with: request, disposer: disposer, reportId: reportId)
  }
  app.on(.POST, "/v2/api/reports/signinfo".asPathComponents) { (request: Request) -> EventLoopFuture<getReportInfoUsingPOST1Response> in
    let body = try request.content.decode(CheckSignRequestDTO.self)
    return try reports.getReportInfoUsingPOST1(with: request, body: body)
  }
  app.on(.GET, "/v2/api/reports/report_types/{id}".asPathComponents) { (request: Request) -> EventLoopFuture<getReportTypeUsingGETResponse> in
    guard let &#x60;id&#x60; = request.parameters.get("&#x60;id&#x60;", as: Int.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter &#x60;id&#x60;")
    }
    return try reports.getReportTypeUsingGET(with: request, &#x60;id&#x60;: &#x60;id&#x60;)
  }
  app.on(.GET, "/v2/api/reports/report_types/".asPathComponents) { (request: Request) -> EventLoopFuture<getReportTypesUsingGETResponse> in
    return try reports.getReportTypesUsingGET(with: request)
  }
  app.on(.GET, "/v2/api/reports/{disposer}/{reportId}".asPathComponents) { (request: Request) -> EventLoopFuture<getReportUsingGETResponse> in
    guard let disposer = request.parameters.get("disposer", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter disposer")
    }
    guard let reportId = request.parameters.get("reportId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter reportId")
    }
    return try reports.getReportUsingGET(with: request, disposer: disposer, reportId: reportId)
  }
  app.on(.GET, "/v2/api/reports/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET6Response> in
    return try reports.pingUsingGET6(with: request)
  }
  //for statistic
  app.on(.GET, "/v2/api/transactions/stat".asPathComponents) { (request: Request) -> EventLoopFuture<geAllStatUsingGETResponse> in
    return try statistic.geAllStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/stat/cabinet".asPathComponents) { (request: Request) -> EventLoopFuture<getCabinetPageStatUsingGETResponse> in
    let kopfg = try? request.query.get(Int.self, at: "kopfg")
    let regionId = try? request.query.get(Int.self, at: "regionId")
    let page = try? request.query.get(Int.self, at: "page")
    let pageSize = try? request.query.get(Int.self, at: "pageSize")
    return try statistic.getCabinetPageStatUsingGET(with: request, kopfg: kopfg, regionId: regionId, page: page, pageSize: pageSize)
  }
  app.on(.GET, "/v2/stat/organizations/csv".asPathComponents) { (request: Request) -> EventLoopFuture<getCsvStatsUsingGETResponse> in
    return try statistic.getCsvStatsUsingGET(with: request)
  }
  app.on(.GET, "/v2/api/transactions/stat/month".asPathComponents) { (request: Request) -> EventLoopFuture<getCurrMonthStatUsingGETResponse> in
    return try statistic.getCurrMonthStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/api/transactions/stat/year".asPathComponents) { (request: Request) -> EventLoopFuture<getCurrYearStatUsingGETResponse> in
    return try statistic.getCurrYearStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/stat/documents".asPathComponents) { (request: Request) -> EventLoopFuture<getDocStatUsingGETResponse> in
    return try statistic.getDocStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/stat/dynamics".asPathComponents) { (request: Request) -> EventLoopFuture<getDynamicsByPeriodsUsingGETResponse> in
    return try statistic.getDynamicsByPeriodsUsingGET(with: request)
  }
  app.on(.GET, "/v2/stat/kopfg".asPathComponents) { (request: Request) -> EventLoopFuture<getKopfgStatUsingGETResponse> in
    return try statistic.getKopfgStatUsingGET(with: request)
  }
  app.on(.GET, "/v2/disposers/stat/{edrpou}".asPathComponents) { (request: Request) -> EventLoopFuture<getStatUsingGETResponse> in
    guard let edrpou = request.parameters.get("edrpou", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter edrpou")
    }
    return try statistic.getStatUsingGET(with: request, edrpou: edrpou)
  }
  app.on(.GET, "/v2/api/transactions/stat/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET10Response> in
    return try statistic.pingUsingGET10(with: request)
  }
  app.on(.GET, "/v2/stat/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET7Response> in
    return try statistic.pingUsingGET7(with: request)
  }
  //for transactions
  app.on(.GET, "/v2/api/transactions/page/".asPathComponents) { (request: Request) -> EventLoopFuture<getPageUsingGET1Response> in
    let payersEdrpous = try? request.query.get([String].self, at: "payersEdrpous")
    let reciptEdrpous = try? request.query.get([String].self, at: "reciptEdrpous")
    let regions = try? request.query.get([Int].self, at: "regions")
    let source = try? request.query.get(String.self, at: "source")
    let startdate = try? request.query.get(Date.self, at: "startdate")
    let enddate = try? request.query.get(Date.self, at: "enddate")
    let payerAccount = try? request.query.get(String.self, at: "payerAccount")
    let reciptAccount = try? request.query.get(String.self, at: "reciptAccount")
    let sumFrom = try? request.query.get(Decimal.self, at: "sumFrom")
    let sumTo = try? request.query.get(Decimal.self, at: "sumTo")
    let purpose = try? request.query.get(String.self, at: "purpose")
    let payerName = try? request.query.get(String.self, at: "payerName")
    let reciptName = try? request.query.get(String.self, at: "reciptName")
    let payerNameEdrpou = try? request.query.get(String.self, at: "payerNameEdrpou")
    let reciptNameEdrpou = try? request.query.get(String.self, at: "reciptNameEdrpou")
    let page = try? request.query.get(Int.self, at: "page")
    let pageSize = try? request.query.get(Int.self, at: "pageSize")
    return try transactions.getPageUsingGET1(with: request, payersEdrpous: payersEdrpous, reciptEdrpous: reciptEdrpous, regions: regions, source: source, startdate: startdate, enddate: enddate, payerAccount: payerAccount, reciptAccount: reciptAccount, sumFrom: sumFrom, sumTo: sumTo, purpose: purpose, payerName: payerName, reciptName: reciptName, payerNameEdrpou: payerNameEdrpou, reciptNameEdrpou: reciptNameEdrpou, page: page, pageSize: pageSize)
  }
  app.on(.GET, "/v2/api/transactions/top100".asPathComponents) { (request: Request) -> EventLoopFuture<getTop100UsingGETResponse> in
    let region = try? request.query.get([Int].self, at: "region")
    return try transactions.getTop100UsingGET(with: request, region: region)
  }
  app.on(.GET, "/v2/api/transactions/top5".asPathComponents) { (request: Request) -> EventLoopFuture<getTop5UsingGETResponse> in
    return try transactions.getTop5UsingGET(with: request)
  }
  app.on(.GET, "/v2/api/transactions/{disposer}/{transactionId}".asPathComponents) { (request: Request) -> EventLoopFuture<getTransactionDetailsUsingGETResponse> in
    guard let disposer = request.parameters.get("disposer", as: String.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter disposer")
    }
    guard let transactionId = request.parameters.get("transactionId", as: Int64.self) else {
      throw Abort(HTTPResponseStatus.badRequest, reason: "Missing parameter transactionId")
    }
    return try transactions.getTransactionDetailsUsingGET(with: request, disposer: disposer, transactionId: transactionId)
  }
  app.on(.GET, "/v2/api/transactions/".asPathComponents) { (request: Request) -> EventLoopFuture<getTransactionsByStreamUsingGETResponse> in
    let payersEdrpous = try? request.query.get([String].self, at: "payersEdrpous")
    let reciptEdrpous = try? request.query.get([String].self, at: "reciptEdrpous")
    let regions = try? request.query.get([Int].self, at: "regions")
    let source = try? request.query.get(String.self, at: "source")
    let startdate = try? request.query.get(Date.self, at: "startdate")
    let enddate = try? request.query.get(Date.self, at: "enddate")
    let payerAccount = try? request.query.get(String.self, at: "payerAccount")
    let reciptAccount = try? request.query.get(String.self, at: "reciptAccount")
    let sumFrom = try? request.query.get(Decimal.self, at: "sumFrom")
    let sumTo = try? request.query.get(Decimal.self, at: "sumTo")
    let purpose = try? request.query.get(String.self, at: "purpose")
    let payerName = try? request.query.get(String.self, at: "payerName")
    let reciptName = try? request.query.get(String.self, at: "reciptName")
    let payerNameEdrpou = try? request.query.get(String.self, at: "payerNameEdrpou")
    let reciptNameEdrpou = try? request.query.get(String.self, at: "reciptNameEdrpou")
    let key = try? request.query.get(String.self, at: "key")
    return try transactions.getTransactionsByStreamUsingGET(with: request, payersEdrpous: payersEdrpous, reciptEdrpous: reciptEdrpous, regions: regions, source: source, startdate: startdate, enddate: enddate, payerAccount: payerAccount, reciptAccount: reciptAccount, sumFrom: sumFrom, sumTo: sumTo, purpose: purpose, payerName: payerName, reciptName: reciptName, payerNameEdrpou: payerNameEdrpou, reciptNameEdrpou: reciptNameEdrpou, key: key)
  }
  app.on(.GET, "/v2/api/transactions/lastload".asPathComponents) { (request: Request) -> EventLoopFuture<lastLoadUsingGET1Response> in
    return try transactions.lastLoadUsingGET1(with: request)
  }
  app.on(.GET, "/v2/api/transactions/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET8Response> in
    return try transactions.pingUsingGET8(with: request)
  }
  app.on(.GET, "/v2/api/transactions/page/ping".asPathComponents) { (request: Request) -> EventLoopFuture<pingUsingGET9Response> in
    return try transactions.pingUsingGET9(with: request)
  }
}

